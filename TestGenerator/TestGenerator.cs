using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace TestGenerator
{
    [Generator]
    public class TestGenerator : IIncrementalGenerator
    {

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Register a syntax receiver to collect information during the initial parsing phase
            var classDeclarations = context.SyntaxProvider.ForAttributeWithMetadataName(
                    "TestGenerator.TestSourceGeneratorAttribute",

                    predicate: static (s, _) => (s is ClassDeclarationSyntax || s is StructDeclarationSyntax) && s is TypeDeclarationSyntax type && type.Modifiers.Any(SyntaxKind.PartialKeyword),
                    transform: static (ctx, _) =>
                    {
                        if (ctx.TargetNode is TypeDeclarationSyntax typeDeclarationSyntax)
                        {
                            return typeDeclarationSyntax.Identifier.ToString();
                        }
                        return null;
                    })
                .Where(static m => m is not null);
            var compilationAndClasses = classDeclarations.Collect();

            // Set up the generation phase
            context.RegisterSourceOutput(compilationAndClasses, static (spc, classes) =>
            {
                foreach (var typeDefinition in classes)
                {
                    // Add the generated source to the output
                    spc.AddSource($"{typeDefinition}.g.cs",
                        SourceText.From(GetSource(typeDefinition), Encoding.UTF8));
                }
            });
        }

        private static string GetSource(string source)
        {
            return $"""
                //<auto-generated/>
                #nullable enable
                using System;
                
                /// {source}
                """;
        }
    }
}
